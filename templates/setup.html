<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Door Setup</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
    /* Area overlay styles */
    .area-overlay {
        position: absolute;
        border: 2px solid #00ff00;
        background: rgba(0, 255, 0, 0.1);
        cursor: move;
        pointer-events: auto;
        z-index: 10;
        box-sizing: border-box;
    }
    
    .area-overlay:hover {
        border-color: #ffff00;
        background: rgba(255, 255, 0, 0.15);
    }
    
    .area-overlay.dragging {
        border-color: #ff0000;
        background: rgba(255, 0, 0, 0.2);
    }
    
    .area-label {
        position: absolute;
        top: -25px;
        left: 0;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 2px 6px;
        font-size: 12px;
        border-radius: 3px;
        white-space: nowrap;
        pointer-events: none;
    }
    
    /* Resize handles */
    .resize-handle {
        position: absolute;
        width: 10px;
        height: 10px;
        background: #ffff00;
        border: 1px solid #000;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 20;
    }
    
    .area-overlay:hover .resize-handle {
        opacity: 1;
    }
    
    .resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
    .resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
    .resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
    .resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
    
    /* Snapshot wrapper positioning */
    #snapshot-wrapper {
        position: relative;
        display: inline-block;
    }
    
    #snapshot-image {
        display: block;
        max-width: 100%;
        height: auto;
    }
    </style>
</head>
<body>

<div class="container">
    <div class="card">
        <div class="header">
            <h1>üîß Cat Door Setup</h1>
            <a href="/" class="nav-link">&larr; Back to Main Page</a>
        </div>
        <div class="setup-instructions">
            <h3>üìã Quick Setup Guide for Raspberry Pi 5 with Hailo AI</h3>
            <ol>
                <li><strong>Take a snapshot</strong> of the camera view showing the areas where cats approach</li>
                <li><strong>Draw detection areas</strong> by holding Shift and dragging rectangles around each cat's door area</li>
                <li><strong>Move existing areas</strong> by clicking and dragging them to new positions</li>
                <li><strong>Resize areas</strong> by dragging the corner handles that appear when you hover over an area</li>
                <li><strong>Configure each cat:</strong>
                    <ul>
                        <li>Enter cat name (e.g., "Misa", "Felix")</li>
                        <li>Select door ID (door1 or door2)</li>
                        <li>Choose expected cat color type: Orange (lighter/ginger cats), Black (darker cats), or Any (no filtering)</li>
                    </ul>
                </li>
                <li><strong>Save and test</strong> - the Hailo AI will detect cats and verify their color before opening doors</li>
            </ol>
            <p><strong>üí° How it works:</strong> The Hailo-8L AI accelerator runs YOLOv6n to detect cats at ~15 FPS, then verifies the cat's color matches your configuration before allowing door access.</p>
            <p><strong>‚ö° Hardware Acceleration:</strong> Processing is hardware-accelerated with negligible CPU usage, allowing smooth video streaming and responsive detection.</p>
        </div>
    </div>

    <div class="layout-container">
        <div class="layout-left">
            <div class="card">
                <h2>1. Live Preview & Snapshot</h2>
                <p>Watch the live stream, then click the button to capture a static image for setup.</p>
                <img id="video-preview" src="{{ url_for('video_feed') }}" alt="Live Camera Feed">
                <br><br>
                <button id="snapshot-btn" class="primary">Take Snapshot</button>
            </div>
            <div class="card">
                <h2>2. Define Detection Areas & Configure Cats</h2>
                <p>
                    - To create a new <strong>Detection Area</strong>, hold <strong>Shift</strong> and drag on the snapshot below.<br>
                    - To <strong>move an existing area</strong>, click and drag it to a new position.<br>
                    - <strong>‚ö° Hailo AI Detection</strong> automatically identifies cats and verifies their color at ~15 FPS using hardware acceleration.<br>
                    - Select the <strong>Expected Cat Color Type</strong> (Orange/Black/Any) for each area to ensure only the correct cat can open the door.
                </p>
                <div id="snapshot-wrapper"></div>
                <div id="status-message"></div>
            </div>
        </div>
        <div class="layout-right">
            <div class="card">
                <h2>3. Saved Configuration</h2>
                <div id="areas-container"></div>
                <button id="save-btn" class="secondary">Save All Changes</button>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Element References & State ---
    const snapshotWrapper = document.getElementById('snapshot-wrapper');
    const areasContainer = document.getElementById('areas-container');
    const statusMessage = document.getElementById('status-message');
    let snapshotImage = null;
    let areas = [];
    let isDrawing = false, startX, startY, currentRect = null;
    let samplingState = { areaIndex: null, isForbidden: false };
    
    let videoInfo = { width: 1280, height: 720 }; // Default values

    // --- Core Functions ---
    async function loadVideoInfo() {
        try {
            const response = await fetch('/api/video_info');
            videoInfo = await response.json();
        } catch(error) {
            console.error("Could not fetch video info, using defaults.", error);
        }
    }

    async function stopDrawing() {
        if (!isDrawing || !currentRect) return;
        isDrawing = false;
        
        const drawnLeft = parseFloat(currentRect.style.left);
        const drawnTop = parseFloat(currentRect.style.top);
        const drawnWidth = parseFloat(currentRect.style.width);
        const drawnHeight = parseFloat(currentRect.style.height);

        currentRect.remove();
        currentRect = null;
        
        if (drawnWidth < 5 || drawnHeight < 5) {
            samplingState.areaIndex = null;
            statusMessage.textContent = '';
            return;
        }

        const displayWidth = snapshotImage.clientWidth;
        const displayHeight = snapshotImage.clientHeight;
        const actualWidth = videoInfo.width;
        const actualHeight = videoInfo.height;

        const scaleX = actualWidth / displayWidth;
        const scaleY = actualHeight / displayHeight;
        
        const scaledRect = [
            Math.round(drawnLeft * scaleX),
            Math.round(drawnTop * scaleY),
            Math.round(drawnWidth * scaleX),
            Math.round(drawnHeight * scaleY)
        ];

        if (samplingState.areaIndex !== null) {
            await sampleColorFromRect(scaledRect, samplingState.areaIndex, samplingState.isForbidden);
            samplingState.areaIndex = null;
            statusMessage.textContent = '';
        } else {
            const areaName = prompt('Enter a name for this new detection area (cat name):', `Cat ${areas.length + 1}`);
            if (areaName) {
                // Create new area with Hailo AI detection defaults
                const newArea = {
                    name: areaName, 
                    door_id: "door1", 
                    rect: scaledRect,
                    expected_color: "any"  // Default to any cat
                };
                areas.push(newArea);
                renderAreas();
                statusMessage.textContent = `Created new detection area for ${areaName}. Configure cat color type below.`;
                statusMessage.style.color = 'green';
                setTimeout(() => { statusMessage.textContent = ''; }, 5000);
            }
        }
    }

    async function sampleColorFromRect(rect, areaIndex, isForbidden) {
        statusMessage.textContent = 'Sampling...';
        try {
            const response = await fetch('/api/hsv_from_rect', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ rect: rect }) });
            const data = await response.json();
            if (!data.ok) throw new Error(data.error);

            const profileType = isForbidden ? "forbidden" : "allowed";
            const profileName = prompt(`Enter a name for this new ${profileType} color profile:`);
            if (profileName) {
                const targetArrayKey = isForbidden ? "forbidden_profiles" : "profiles";
                if (!areas[areaIndex][targetArrayKey]) areas[areaIndex][targetArrayKey] = [];
                areas[areaIndex][targetArrayKey].push({ label: profileName, hsv_lo: data.hsv_lo, hsv_hi: data.hsv_hi });
                renderAreas();
            }
        } catch (error) {
            alert(`Failed to sample color: ${error.message}`);
        }
    }
    
    function startDrawing(e) { 
        if (!snapshotImage || (!e.shiftKey && samplingState.areaIndex === null)) return; 
        isDrawing = true; 
        const rect = snapshotImage.getBoundingClientRect(); 
        startX = e.clientX - rect.left; 
        startY = e.clientY - rect.top; 
        currentRect = document.createElement('div'); 
        currentRect.className = (samplingState.areaIndex !== null) ? 'rect rect-sample' : 'rect rect-area'; 
        currentRect.style.left = `${startX}px`; 
        currentRect.style.top = `${startY}px`; 
        snapshotWrapper.appendChild(currentRect); 
    }
    
    function draw(e) { 
        if (!isDrawing || !currentRect || !snapshotImage) return; 
        const rect = snapshotImage.getBoundingClientRect(); 
        const currentX = e.clientX - rect.left; 
        const currentY = e.clientY - rect.top; 
        const width = currentX - startX; 
        const height = currentY - startY; 
        currentRect.style.width = `${Math.abs(width)}px`; 
        currentRect.style.height = `${Math.abs(height)}px`; 
        currentRect.style.left = `${width > 0 ? startX : currentX}px`; 
        currentRect.style.top = `${height > 0 ? startY : currentY}px`; 
    }

    function renderAreas() { 
        areasContainer.innerHTML = ''; 
        if (areas.length === 0) { 
            areasContainer.innerHTML = '<p>No areas defined yet.</p>'; 
            return; 
        } 
        areas.forEach((area, index) => { 
            const areaElem = document.createElement('div'); 
            areaElem.className = 'area-item'; 
            
            // Create the enhanced area configuration HTML
            areaElem.innerHTML = `
                <h3>üê± Cat Configuration - Area ${index + 1}</h3>
                <div class="cat-config-section">
                    <p><strong>Cat Name:</strong> <input type="text" value="${area.name}" class="area-prop" data-index="${index}" data-prop="name" placeholder="Enter cat name (e.g., Misa, Felix)"></p>
                    <p><strong>Door ID:</strong> <input type="text" value="${area.door_id}" class="area-prop" data-index="${index}" data-prop="door_id" placeholder="door1"></p>
                    
                    <div class="cat-color-section" style="margin: 15px 0; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                        <p><strong>üé® Expected Cat Color Type:</strong></p>
                        <div style="margin-left: 20px;">
                            <label style="display: block; margin: 5px 0;">
                                <input type="radio" name="cat_color_${index}" value="orange" ${(area.expected_color === 'orange') ? 'checked' : ''} class="cat-color-type" data-index="${index}"> 
                                üü† Lighter/Orange Cat (e.g., Misa, ginger cats)
                            </label>
                            <label style="display: block; margin: 5px 0;">
                                <input type="radio" name="cat_color_${index}" value="black" ${(area.expected_color === 'black') ? 'checked' : ''} class="cat-color-type" data-index="${index}"> 
                                ‚ö´ Darker/Black Cat (e.g., Felix, dark cats)
                            </label>
                            <label style="display: block; margin: 5px 0;">
                                <input type="radio" name="cat_color_${index}" value="any" ${(!area.expected_color || area.expected_color === 'any') ? 'checked' : ''} class="cat-color-type" data-index="${index}"> 
                                üîµ Any Cat (no color filtering)
                            </label>
                        </div>
                        <p style="font-size: 0.85em; color: #666; margin-top: 8px;">
                            üí° The Hailo AI will detect cats and verify their color matches this setting before opening the door.
                        </p>
                    </div>
                    
                    <div class="hailo-info-section" style="margin: 15px 0; padding: 10px; background: #e8f5e9; border-radius: 5px; border-left: 4px solid #4caf50;">
                        <p style="margin: 5px 0;"><strong>‚ö° Hailo AI Detection Active</strong></p>
                        <p style="font-size: 0.85em; color: #555; margin: 5px 0;">
                            ‚úÖ Hardware-accelerated with Hailo-8L AI chip<br>
                            üéØ Detection runs within your configured area<br>
                            üê± YOLOv6n model detecting cats at ~15 FPS<br>
                            üé® Color verification using your selected cat type
                        </p>
                    </div>
                </div>
                <button class="remove-btn danger" data-index="${index}">üóëÔ∏è Remove This Cat Area</button>
            `; 
            areasContainer.appendChild(areaElem); 
        }); 
        
        // Add event listeners for detection method radio buttons
        document.querySelectorAll('.detection-method').forEach(radio => {
            radio.addEventListener('change', function() {
                const index = parseInt(this.dataset.index);
                const method = this.value;
                areas[index].detection_method = method;
                
                // Show/hide appropriate configuration sections
                const sizeSection = document.querySelector(`.size-config-section[data-index="${index}"]`);
                const yoloSection = document.querySelector(`.yolo-config-section[data-index="${index}"]`);
                const colorSection = document.querySelector(`.color-config-section[data-index="${index}"]`);
                
                // Hide all sections first
                sizeSection.style.display = 'none';
                yoloSection.style.display = 'none';
                colorSection.style.display = 'none';
                
                // Show the appropriate section
                if (method === 'size_based') {
                    sizeSection.style.display = 'block';
                } else if (method === 'yolo_based') {
                    yoloSection.style.display = 'block';
                } else if (method === 'color_based') {
                    colorSection.style.display = 'block';
                }
            });
        });
        
        // Add event listeners for YOLO class checkboxes
        document.querySelectorAll('.yolo-class').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const index = parseInt(this.dataset.index);
                const className = this.dataset.class;
                
                if (!areas[index].yolo_classes) {
                    areas[index].yolo_classes = [];
                }
                
                if (this.checked) {
                    if (!areas[index].yolo_classes.includes(className)) {
                        areas[index].yolo_classes.push(className);
                    }
                } else {
                    areas[index].yolo_classes = areas[index].yolo_classes.filter(c => c !== className);
                }
            });
        });
        
        // Add event listeners for cat color type radio buttons
        document.querySelectorAll('.cat-color-type').forEach(radio => {
            radio.addEventListener('change', function() {
                const index = parseInt(this.dataset.index);
                const colorType = this.value;
                areas[index].expected_color = colorType;
                console.log(`Area ${index} (${areas[index].name}) color type set to: ${colorType}`);
            });
        });
        
        // Render visual overlays after updating the areas list
        setTimeout(renderAreaOverlays, 100); // Small delay to ensure DOM is updated
    }
    
    // --- Visual Overlay Functions ---
    function renderAreaOverlays() {
        // Clear existing overlays
        const existingOverlays = document.querySelectorAll('.area-overlay');
        existingOverlays.forEach(overlay => overlay.remove());
        
        const snapshotWrapper = document.getElementById('snapshot-wrapper');
        const snapshotImage = document.getElementById('snapshot-image');
        
        if (!snapshotImage || !snapshotImage.complete || !snapshotWrapper) return;
        
        // Calculate scaling factors
        const scaleX = snapshotImage.offsetWidth / snapshotImage.naturalWidth;
        const scaleY = snapshotImage.offsetHeight / snapshotImage.naturalHeight;
        
        areas.forEach((area, index) => {
            const overlay = document.createElement('div');
            overlay.className = 'area-overlay';
            overlay.dataset.areaIndex = index;
            
            // Position and size overlay
            overlay.style.left = (area.x * scaleX) + 'px';
            overlay.style.top = (area.y * scaleY) + 'px';
            overlay.style.width = (area.width * scaleX) + 'px';
            overlay.style.height = (area.height * scaleY) + 'px';
            
            // Add label
            const label = document.createElement('div');
            label.className = 'area-label';
            label.textContent = area.name || `Area ${index + 1}`;
            overlay.appendChild(label);
            
            // Add resize handles
            const handles = ['nw', 'ne', 'sw', 'se'];
            handles.forEach(handleType => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${handleType}`;
                handle.dataset.handleType = handleType;
                overlay.appendChild(handle);
            });
            
            // Add event listeners
            addOverlayListeners(overlay, index);
            
            snapshotWrapper.appendChild(overlay);
        });
    }
    
    function addOverlayListeners(overlay, areaIndex) {
        let isDragging = false;
        let isResizing = false;
        let dragStart = { x: 0, y: 0 };
        let originalArea = {};
        let resizeHandle = null;
        
        // Mouse down on overlay (drag) or handle (resize)
        overlay.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const snapshotImage = document.getElementById('snapshot-image');
            const scaleX = snapshotImage.offsetWidth / snapshotImage.naturalWidth;
            const scaleY = snapshotImage.offsetHeight / snapshotImage.naturalHeight;
            
            if (e.target.classList.contains('resize-handle')) {
                // Start resizing
                isResizing = true;
                resizeHandle = e.target.dataset.handleType;
                overlay.classList.add('dragging');
                
                originalArea = {
                    x: areas[areaIndex].x,
                    y: areas[areaIndex].y,
                    width: areas[areaIndex].width,
                    height: areas[areaIndex].height
                };
                
                dragStart = {
                    x: e.clientX,
                    y: e.clientY
                };
            } else {
                // Start dragging
                isDragging = true;
                overlay.classList.add('dragging');
                
                dragStart = {
                    x: e.clientX - overlay.offsetLeft,
                    y: e.clientY - overlay.offsetTop
                };
            }
        });
        
        // Mouse move (global listener added below)
        function handleMouseMove(e) {
            if (isDragging) {
                const snapshotWrapper = document.getElementById('snapshot-wrapper');
                const snapshotImage = document.getElementById('snapshot-image');
                const scaleX = snapshotImage.offsetWidth / snapshotImage.naturalWidth;
                const scaleY = snapshotImage.offsetHeight / snapshotImage.naturalHeight;
                
                // Calculate new position
                let newX = e.clientX - dragStart.x;
                let newY = e.clientY - dragStart.y;
                
                // Constrain to image bounds
                newX = Math.max(0, Math.min(newX, snapshotImage.offsetWidth - overlay.offsetWidth));
                newY = Math.max(0, Math.min(newY, snapshotImage.offsetHeight - overlay.offsetHeight));
                
                // Update overlay position
                overlay.style.left = newX + 'px';
                overlay.style.top = newY + 'px';
                
                // Update area data
                areas[areaIndex].x = Math.round(newX / scaleX);
                areas[areaIndex].y = Math.round(newY / scaleY);
                
            } else if (isResizing) {
                const snapshotImage = document.getElementById('snapshot-image');
                const scaleX = snapshotImage.offsetWidth / snapshotImage.naturalWidth;
                const scaleY = snapshotImage.offsetHeight / snapshotImage.naturalHeight;
                
                const deltaX = (e.clientX - dragStart.x) / scaleX;
                const deltaY = (e.clientY - dragStart.y) / scaleY;
                
                let newArea = { ...originalArea };
                
                // Apply resize based on handle type
                switch (resizeHandle) {
                    case 'nw':
                        newArea.x = originalArea.x + deltaX;
                        newArea.y = originalArea.y + deltaY;
                        newArea.width = originalArea.width - deltaX;
                        newArea.height = originalArea.height - deltaY;
                        break;
                    case 'ne':
                        newArea.y = originalArea.y + deltaY;
                        newArea.width = originalArea.width + deltaX;
                        newArea.height = originalArea.height - deltaY;
                        break;
                    case 'sw':
                        newArea.x = originalArea.x + deltaX;
                        newArea.width = originalArea.width - deltaX;
                        newArea.height = originalArea.height + deltaY;
                        break;
                    case 'se':
                        newArea.width = originalArea.width + deltaX;
                        newArea.height = originalArea.height + deltaY;
                        break;
                }
                
                // Enforce minimum size
                newArea.width = Math.max(20, newArea.width);
                newArea.height = Math.max(20, newArea.height);
                
                // Constrain to image bounds
                newArea.x = Math.max(0, Math.min(newArea.x, snapshotImage.naturalWidth - newArea.width));
                newArea.y = Math.max(0, Math.min(newArea.y, snapshotImage.naturalHeight - newArea.height));
                
                // Update area data
                areas[areaIndex] = { ...areas[areaIndex], ...newArea };
                
                // Update overlay
                overlay.style.left = (newArea.x * scaleX) + 'px';
                overlay.style.top = (newArea.y * scaleY) + 'px';
                overlay.style.width = (newArea.width * scaleX) + 'px';
                overlay.style.height = (newArea.height * scaleY) + 'px';
            }
        }
        
        // Mouse up (global listener added below)
        function handleMouseUp() {
            if (isDragging || isResizing) {
                overlay.classList.remove('dragging');
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
                
                // Update the areas list display
                renderAreas();
                
                // Remove global listeners
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
        }
        
        // Add global listeners when starting drag/resize
        overlay.addEventListener('mousedown', function() {
            if (isDragging || isResizing) {
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            }
        });
    }
    
    // --- Size Preset Function ---
    function applySizePreset(areaIndex, presetType) {
        const presets = {
            'small': { min: 3000, max: 8000, contour: 300 },
            'medium': { min: 8000, max: 15000, contour: 500 },
            'large': { min: 15000, max: 30000, contour: 700 }
        };
        
        const preset = presets[presetType];
        if (!preset) return;
        
        // Update the area object
        areas[areaIndex].size_threshold_min = preset.min;
        areas[areaIndex].size_threshold_max = preset.max;
        areas[areaIndex].min_contour_area = preset.contour;
        
        // Update the UI inputs
        document.querySelector(`input[data-index="${areaIndex}"][data-prop="size_threshold_min"]`).value = preset.min;
        document.querySelector(`input[data-index="${areaIndex}"][data-prop="size_threshold_max"]`).value = preset.max;
        document.querySelector(`input[data-index="${areaIndex}"][data-prop="min_contour_area"]`).value = preset.contour;
        
        statusMessage.textContent = `Applied ${presetType} cat preset to ${areas[areaIndex].name || 'Area ' + (areaIndex + 1)}`;
        statusMessage.style.color = 'green';
        setTimeout(() => { statusMessage.textContent = ''; }, 3000);
    }
    
    async function takeSnapshot() { 
        snapshotWrapper.innerHTML = '<p>Loading...</p>'; 
        statusMessage.textContent = ''; 
        samplingState.areaIndex = null; 
        try { 
            const response = await fetch('/api/snapshot', { method: 'POST' }); 
            if (!response.ok) throw new Error('Snapshot failed'); 
            const imageBlob = await response.blob(); 
            const imageUrl = URL.createObjectURL(imageBlob); 
            snapshotWrapper.innerHTML = ''; 
            snapshotImage = document.createElement('img'); 
            snapshotImage.id = 'snapshot-image'; 
            snapshotImage.src = imageUrl; 
            snapshotWrapper.appendChild(snapshotImage); 
            snapshotImage.addEventListener('mousedown', startDrawing);
            snapshotImage.addEventListener('load', renderAreaOverlays); 
            snapshotImage.addEventListener('mousemove', draw); 
            document.addEventListener('mouseup', stopDrawing); 
        } catch (error) { 
            snapshotWrapper.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`; 
        } 
    } 
    
    async function loadConfig() { 
        try { 
            const response = await fetch('/api/config'); 
            const data = await response.json(); 
            areas = data.areas || []; 
            
            // Convert rect format [x, y, width, height] to individual properties
            areas.forEach(area => {
                if (area.rect && Array.isArray(area.rect) && area.rect.length === 4) {
                    area.x = area.rect[0];
                    area.y = area.rect[1];
                    area.width = area.rect[2];
                    area.height = area.rect[3];
                }
            });
            
            renderAreas(); 
        } catch (error) { 
            console.error('Failed to load config:', error); 
        } 
    } 
    
    async function saveConfig() { 
        try { 
            // Convert individual x, y, width, height properties back to rect format for saving
            const areasToSave = areas.map(area => {
                const areaCopy = { ...area };
                if (areaCopy.x !== undefined && areaCopy.y !== undefined && 
                    areaCopy.width !== undefined && areaCopy.height !== undefined) {
                    areaCopy.rect = [areaCopy.x, areaCopy.y, areaCopy.width, areaCopy.height];
                    // Remove individual properties to avoid duplication
                    delete areaCopy.x;
                    delete areaCopy.y;
                    delete areaCopy.width;
                    delete areaCopy.height;
                }
                return areaCopy;
            });
            
            const response = await fetch('/api/config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ areas: areasToSave }) }); 
            const result = await response.json(); 
            if (result.ok) { 
                alert('Configuration saved!'); 
            } else { 
                throw new Error(result.error || 'Unknown error'); 
            } 
        } catch (error) { 
            alert(`Failed to save: ${error.message}`); 
        } 
    }

    // --- Event Listeners ---
    document.getElementById('snapshot-btn').addEventListener('click', takeSnapshot);
    document.getElementById('save-btn').addEventListener('click', saveConfig);
    
    // Event Delegation for dynamically created elements inside areasContainer
    areasContainer.addEventListener('change', (e) => {
        if (e.target.classList.contains('area-prop')) {
            const index = e.target.dataset.index;
            const prop = e.target.dataset.prop;
            areas[index][prop] = e.target.type === 'number' ? parseInt(e.target.value, 10) : e.target.value;
        }
    });

    areasContainer.addEventListener('click', (e) => {
        const target = e.target;
        if (target.classList.contains('add-profile-btn')) {
            samplingState.areaIndex = parseInt(target.dataset.index, 10);
            samplingState.isForbidden = target.dataset.isForbidden === 'true';
            const type = samplingState.isForbidden ? "forbidden" : "allowed";
            statusMessage.textContent = `Sampling for ${type} profile for "${areas[samplingState.areaIndex].name}". Draw on snapshot.`;
            window.scrollTo({ top: snapshotWrapper.offsetTop - 20, behavior: 'smooth' });
        }
        if (target.classList.contains('remove-profile-btn')) {
            const areaIndex = target.dataset.areaIndex;
            const profileIndex = target.dataset.profileIndex;
            const isForbidden = target.dataset.isForbidden === 'true';
            const targetArray = isForbidden ? areas[areaIndex].forbidden_profiles : areas[areaIndex].profiles;
            if (confirm(`Delete profile "${targetArray[profileIndex].label}"?`)) {
                targetArray.splice(profileIndex, 1);
                renderAreas();
            }
        }
        if (target.classList.contains('remove-btn')) {
            const index = target.dataset.index;
            if (confirm(`Remove area "${areas[index].name}"?`)) {
                areas.splice(index, 1);
                renderAreas();
            }
        }
    });

    // --- Window resize handler ---
    window.addEventListener('resize', function() {
        setTimeout(renderAreaOverlays, 100);
    });
    
    // --- Initial Load ---
    loadVideoInfo();
    loadConfig();
});
</script>

</body>
</html>